問題文を見たときの第一印象　あ、ゲームだ。壊しにくいブロックと壊しやすいブロックが存在して、ブロックを壊しながら進むゲームあるよね、あれだわ。

考えること
・家の数の違い。家の数が多いときは、それまでに開拓した水路を使う方法を模索する。
・Cの値の違い。Cの値が小さいときはある程度無駄な探索が許容されるが、Cが大きいとコストを小さくすることを目指したほうが良い。
・インタラクティブに実行するとき（後戻りができない）とき、マップの把握はどうすればよいか


2/20
ローカルテスタ（ローカルインタラクティブ環境）をつくらないといけない。これがないとコードをテストできない。
・ローカルテスタ
1. 出力(row,column,power)を受け取る
2. cost=power+Cを、その座標のDestLevelから引く
3. 2の値が0以下 -> 掘削完了。1を返す。
          0より大きい -> 掘削できなかった。0を返す。
出力が水源の座標と一致するとき、特別な処理を行う。掘削が完了した場合、brokehouse++し、この値が家の数に等しくなったら2を返す。
それ以外(0<=row,column<=199, 1<=power<=5000)の場合、-1を返す。

その他の機能
・水が通った家の数を把握する。掘削する岩の座標が家の座標と同じであるか判断し、その岩が壊れたらbrokenhouse++する。
・コストの合計

ローカルテスタを動かすための簡単なコード
・それぞれの家から最も近い水源に向かって直線的に移動する。

今考えている解法
解法1
水源から、ある一定のパワーで掘れる岩をすべて掘っていく。一度訪れた座標には訪れないようにする(2次元配列visitで管理する）。掘ることができた岩の座標をキューに追加して、キューが空になるまで掘る。最大200*200=4000回の探索で済む。
しかし、掘削できた岩が少なすぎる場合は、パワーを大きくしてもう一度探索を行う。
その後、それぞれの家から最も距離が近い水が通っている座標を調べ（マンハッタン距離で探索？座標とマンハッタン距離が与えられたとき、その距離に該当する座標を返す（複数ある）関数を書く。）
解法2
それぞれの家から最も近い水源に向かって以下の操作を行う。現在地を原点（初期座標はそれぞれの家の座標）として、目標の水源へのベクトルを常に持っておく。初期パワーを定め、ベクトルの方向から上下左右4方向のどちらに進めばいいか判断し、その方向に掘り進める。掘れたらパワーを少し小さくする。掘れなかったらパワーを少し大きくするか別方向のマスを掘る。
解法3（というよりかはマップの把握方法）
家または水源から4方向に20マスくらい同じパワーで掘り進めて、破壊できた岩の数でマップを把握する。
（壊れたor壊れてない判定しかしてくれないのがつらい）

LocalTesterと提出用で書き換える部分
・solver->destruct->queryとis_broken

初期解
・最も近い水源に向かって直線的に掘削する。
・掘削が完了した道も水源として扱う

初期解完成 19:15

提出1回目の得点（コスト）19607971

次の方針
・家の座標を、水源に近い順番にキューに追加していく
tupleを用いる。(最も近い水源との距離(初期状態）、house番号、その水源の座標)で、第一要素(距離)で昇順ソート。