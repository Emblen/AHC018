問題文を見たときの第一印象　あ、ゲームだ。壊しにくいブロックと壊しやすいブロックが存在して、ブロックを壊しながら進むゲームあるよね、あれだわ。

考えること
・家の数の違い。家の数が多いときは、それまでに開拓した水路を使う方法を模索する。
・Cの値の違い。Cの値が小さいときはある程度無駄な探索が許容されるが、Cが大きいとコストを小さくすることを目指したほうが良い。
・インタラクティブに実行するとき（後戻りができない）とき、マップの把握はどうすればよいか


2/20
ローカルテスタ（ローカルインタラクティブ環境）をつくらないといけない。これがないとコードをテストできない。
・ローカルテスタ
1. 出力(row,column,power)を受け取る
2. cost=power+Cを、その座標のDestLevelから引く
3. 2の値が0以下 -> 掘削完了。1を返す。
          0より大きい -> 掘削できなかった。0を返す。
出力が水源の座標と一致するとき、特別な処理を行う。掘削が完了した場合、brokehouse++し、この値が家の数に等しくなったら2を返す。
それ以外(0<=row,column<=199, 1<=power<=5000)の場合、-1を返す。

その他の機能
・水が通った家の数を把握する。掘削する岩の座標が家の座標と同じであるか判断し、その岩が壊れたらbrokenhouse++する。
・コストの合計

ローカルテスタを動かすための簡単なコード
・それぞれの家から最も近い水源に向かって直線的に移動する。

今考えている解法
解法1
水源から、ある一定のパワーで掘れる岩をすべて掘っていく。一度訪れた座標には訪れないようにする(2次元配列visitで管理する）。掘ることができた岩の座標をキューに追加して、キューが空になるまで掘る。最大200*200=4000回の探索で済む。
しかし、掘削できた岩が少なすぎる場合は、パワーを大きくしてもう一度探索を行う。
その後、それぞれの家から最も距離が近い水が通っている座標を調べ（マンハッタン距離で探索？座標とマンハッタン距離が与えられたとき、その距離に該当する座標を返す（複数ある）関数を書く。）
解法2
それぞれの家から最も近い水源に向かって以下の操作を行う。現在地を原点（初期座標はそれぞれの家の座標）として、目標の水源へのベクトルを常に持っておく。初期パワーを定め、ベクトルの方向から上下左右4方向のどちらに進めばいいか判断し、その方向に掘り進める。掘れたらパワーを少し小さくする。掘れなかったらパワーを少し大きくするか別方向のマスを掘る。
解法3（というよりかはマップの把握方法）
家または水源から4方向に20マスくらい同じパワーで掘り進めて、破壊できた岩の数でマップを把握する。
（壊れたor壊れてない判定しかしてくれないのがつらい）

LocalTesterと提出用で書き換える部分
・solver->destruct->queryとis_broken

初期解
・最も近い水源に向かって直線的に掘削する。
・掘削が完了した道も水源として扱う

初期解完成 19:15

提出1回目の得点（コスト）19607971

次の方針
・家の座標を、水源に近い順番にキューに追加していく
tupleを用いる。(最も近い水源との距離(初期状態）、house番号、その水源の座標)で、第一要素(距離)で昇順ソート。

2/21
提出2回目（うそ、1回WAしたので3回目）01:54
提出3回目のコスト 14211185 
25%もコスト削減できた！？

次の方針
何マスおきかに一定のパワーで何回か掘削し、何回で壊れたかを調べておおまかなマップをつくる。

代表点の個数を決定する。
代表点について何段階かに分けて掘削を行い、掘削完了までに用いたパワーから頑丈さを予測する。
（代表点は、掘削出来たものについては頑丈さを最後に0にする。できなかったものは、その点に用いたパワーの合計とする（どうせその点の周りも頑丈さが大きいので0にしたり無駄に大きくする必要はなさそう）
予測した頑丈さを用いて他の点の頑丈さを予測する。2つ以上の値を用いてその平均値とする。
それぞれの家から水源までを幅優先探索し、最もコストの小さい水源、経路を求めてクエリに投入していく。
幅優先探索
家を始点としてすべての点についてコストを算出（マンハッタン距離なのでループは最大400回）
→水源である点の中でコスト最小の点を探索。
→経路は？？（探索の過程で点の親となる点を記録しておく。）pair<int(コスト), vec2(親の点)>
各クエリに渡すパワーは？
予測マップで頑丈さが0の点はスルー、


代表点の数 19*19 + 18*18 = 381 + 324 = 685 （おおいな）
代表点をパワー20で掘削->掘削できなかった点を再度コスト50で掘削する→再度80で掘削

探索空間が広すぎるからビームサーチとかやりたい。
いやダイクストラでよくね？

2/23
代表点を掘削してマップを作る。
400点をパワー50で3回掘削するとすると、最大コストは400*(50+128)*3 = 213600?????実用的でない気がする。。。
とりあえず粗めに掘削する。代表点を左上の角とし、10*10の領域をすべて代表点を掘削するのに用いたパワーにする。
代表点のマップ値は最後に0にする。
必要な関数
・代表点を3回掘削する。掘削出来たらその点はもう掘削しない。
・すべての点にマップ値を割り当てる。
・マップを出力する。
壊れた点は探索のときに破壊行為を行わないが、この時点では水源として追加できないので探索の際に破壊済みであれば水源としてあつかう。

代表点20*20=400個でとてもざっくりとしたマップができた。seed=0でコスト55224、これは許容できそう。
mapできたあ

次、ダイクストラを実装する。